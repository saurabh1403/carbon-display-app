<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark"
		 xmlns:mx="library://ns.adobe.com/flex/mx"
		 xmlns:components="view.components.*"
		 width="100%" height="100%" currentState="TestMode"
		 creationComplete="group1_creationCompleteHandler(event)" xmlns:GeneralComponents="view.components.GeneralComponents.*"
		 >
	
	<fx:Script>
		<![CDATA[
			import Controller.DataProcessor;
			import Controller.MCQConstants;
			
			import Events.QuesButtClickEvent;
			import Events.TestResultEvent;
			
			import model.Question;
			import model.QuestionsProxy;
			
			import mx.collections.IViewCursor;
			import mx.events.FlexEvent;
			import mx.formatters.Formatter;
			import mx.managers.PopUpManager;
			
			import org.osmf.events.TimeEvent;
			
			import view.components.GeneralComponents.DetailOverlay;
			
			private var currQuesNumber:int = 0;
			private var totalQuesCount:int = 0;
			
			private var quesAttemptedTrack:Dictionary = new Dictionary();
			private var quesAttempted:int = 0;
			
			[Bindable]
			public var currQuesMark:String = "";
			[Bindable]
			private var timePassed:String = "";
			
			[Bindable]
			private var timeLeft:String = "";		//time which is left to complete the test
			
			private var currViewTimer:Timer = new Timer(1000);
			
			private var currQuesTimer:Timer = new Timer(1000);
			
			//timer related 
			private var secondsPassed:int = 0;			
			private var hourPassed:int = 0;
			private var minutePassed:int = 0;
			
			private var secondsLeft:int = 0;			
			private var hourLeft:int = 0;
			private var minuteLeft:int = 0;

			private var currQues:Question = null;
			
			private var isExplanationExpanded:Boolean = false;
			
			protected function FinishHandler(event:MouseEvent):void
			{
				var resEvent:TestResultEvent = new TestResultEvent(MCQConstants.testCompletedEventName);

				if(currentState == "TestMode")
				{
					currQuesDone();

					resEvent.hourPassed = this.hourPassed;
					resEvent.minutePassed = this.minutePassed;
					resEvent.secondsPassed = this.secondsPassed;

					resEvent.quesAttempted = this.quesAttempted;
					resEvent.totalQuesCount = this.totalQuesCount;
					resEvent.totalTimeTaken = this.timePassed;

					resEvent.isTestMode = true;
					
				}
				
				else
				{
					resEvent.isTestMode = false;
					
				}
				
				dispatchEvent(resEvent);
				
			}
			
			protected function HelpClickHandler(event:MouseEvent):void
			{
				var detailView:DetailOverlay = new DetailOverlay();
				detailView.setCurrentState("TextState");
				detailView.width = MCQConstants.appWidth - 40;
				detailView.height = MCQConstants.appHeight - 40;

				PopUpManager.addPopUp(detailView, this, true);
				PopUpManager.centerPopUp(detailView);
			}
			
			protected function timerHandlerCountDown(event:TimerEvent):void
			{
				secondsLeft--;
				
				if(secondsLeft == -1)
				{
					secondsLeft = 59;
					minuteLeft --;
				}
				
				if(minuteLeft == -1)
				{
					minuteLeft = 59;
					hourLeft--;
				}
				
				if(hourLeft == -1)
				{
					promptTimeOut();
				}
				
				//format the string
				timeLeft = formatTime(hourLeft) + ":" + formatTime(minuteLeft) + ":" + formatTime(secondsLeft);
				
				timerHandlerCountUp(event);

			}
			
			protected function promptTimeOut():void
			{
				
			}
			
			protected function timerHandlerCountUp(event:TimerEvent):void
			{
				secondsPassed++;
				
				if(secondsPassed == 60)
				{
					secondsPassed = 0;
					minutePassed ++;
				}
				
				if(minutePassed == 60)
				{
					minutePassed = 0;
					hourPassed ++;
				}
				
				if(hourPassed == 60)
				{
					hourPassed = 0;
					//TODO: warn the user to quit the test
				}
				
				//format the string
				timePassed = formatTime(hourPassed) + ":" + formatTime(minutePassed) + ":" + formatTime(secondsPassed);
					
			}
			
			protected function formatTime(i:int):String
			{
				//TODO: format the string here. like "0" should be printed as "00"
				return i.toString();
				
			}
			
			protected function group1_creationCompleteHandler(event:FlexEvent):void
			{
				initView();
			}
			
			public function initView(curState:String = "TestMode"):void
			{
//				this.setCurrentState(curState);
				currViewTimer.start();
				
				var quesProxy:QuestionsProxy = DataProcessor.instance.quesProxy;
				
				currQues = quesProxy.questions[currQuesNumber];
				
				//register different handlers
				totalQuesCount = DataProcessor.instance.quesProxy.questions.length;
				
				quesBox.initWtihButtons(totalQuesCount);
				quesBox.addEventListener(MCQConstants.quesButtonClickEventName, quesChangedEventHandler, false, 0, true);
				
				diagram.addEventListener(MCQConstants.diagramClickEventName, diagClicked, false, 0, true);
				
				choiceBox.setCurrentState(currentState);
				
				populateDataOnScreen(currQues);
				
				if(currentState == "TestMode")
				{
					quesProgress.setProgress(quesAttempted, totalQuesCount);
					quesProgress.label = quesAttempted.toString() + "/" + totalQuesCount.toString() + " completed";
					currViewTimer.addEventListener(TimerEvent.TIMER, timerHandlerCountDown, false, 0, true);

					secondsLeft = 0;
					minuteLeft = quesProxy.testTotalTime % 60;
					hourLeft = quesProxy.testTotalTime / 60;
				}
				else
				{
					//TODO: it is not working
					initQuesBoxButtonsInReviewMode();
				}

			}

			public function disposeView():void
			{
				this.removeAllElements();
				
			}

			protected function diagClicked(event:Event):void
			{
				var diagOverlay:DetailOverlay = new DetailOverlay();
				diagOverlay.currentState = "ImageState";
				
				diagOverlay.width = MCQConstants.appWidth - 60;
				diagOverlay.height = MCQConstants.appHeight - 60;
				
				diagOverlay.imagePath = currQues._imagePath;
				
				PopUpManager.addPopUp(diagOverlay, this, true);
				PopUpManager.centerPopUp(diagOverlay);

			}
			
			//this commits all the data for the current question
			//this is called only when the question is changed
			protected function currQuesDone():void
			{
				choiceBox.commitSelectedOptions();
				currQues.quesAttemptTime += currQuesTimer.currentCount;
				
				if(currQues.isQuesAttempted == true && quesAttemptedTrack[currQuesNumber] == null)
				{
					quesAttemptedTrack[currQuesNumber] = true;
					quesAttempted++;
				}
				
				if(currQues.isQuesMarkedForReview)
					quesBox.setButtonColor(currQuesNumber,MCQConstants.quesStateColor["quesReviewState"] as int);
				
				else if(currQues.isQuesAttempted)
					quesBox.setButtonColor(currQuesNumber,MCQConstants.quesStateColor["quesAttempted"] as int);

				else
					quesBox.setButtonColor(currQuesNumber,MCQConstants.quesStateColor["quesUnAttempted"] as int);

				//update the progress bar
				quesProgress.setProgress(quesAttempted, totalQuesCount);
				quesProgress.label = quesAttempted.toString() + "/" + totalQuesCount.toString() + " completed";
				
			}
			
			protected function initQuesBoxButtonsInReviewMode():void
			{
				var quesItr:IViewCursor = DataProcessor.instance.quesProxy.questions.createCursor();
				var i:int = 0;
				while(!quesItr.afterLast)
				{
					var tempColor:int;
					if((quesItr.current as Question).userAnswer == -1)
					{
						tempColor = MCQConstants.quesStateColor["quesUnAttempted"];
					}
					else if((quesItr.current as Question).isQuesCorrect())
					{
						tempColor = MCQConstants.quesStateColor["quesIsRight"];
					}
					else
					{
						tempColor = MCQConstants.quesStateColor["quesIsWrong"];
					}
					
					quesBox.setButtonColor(i, tempColor);
					i++;
					quesItr.moveNext();
				}
			}
			
			protected function quesChangedEventHandler(event:Event):void
			{
				//get the event data from here
				//commit the data in choice box here
				
				if(currentState == "TestMode")
					currQuesDone();

//				else
//					quesBox.setButtonColor(currQuesNumber,MCQConstants.quesStateColor["quesUnAttempted"] as int);

				if(event.target.id == "nextButton")
					currQuesNumber = ((currQuesNumber + 1) % totalQuesCount);

				else if(event.target.id == "prevButton")
				{
					if(currQuesNumber == 0)
						currQuesNumber = totalQuesCount - 1;
					else
						currQuesNumber = (currQuesNumber - 1);
				}

				else
				{
					var newEvent:QuesButtClickEvent = event as QuesButtClickEvent;
					
					currQuesNumber = newEvent.buttNumber;
				}
				
				trace("currQues is" + currQuesNumber.toString());
				
				currQues = DataProcessor.instance.quesProxy.questions[currQuesNumber];
				populateDataOnScreen(currQues);
			}
			
			protected function populateDataOnScreen(_currQues:Question):void
			{
				if(currentState == "TestMode")
				{
					currQuesTimer.reset();
					currQuesTimer.start();
					quesReviewCheckBox.selected = (_currQues.isQuesMarkedForReview);
					quesBox.setButtonColor(currQuesNumber, MCQConstants.quesStateColor["currQuesSelected"] as int);
				}
				
				else
				{
					isExplanationExpanded = false;
					quesExplanation.percentHeight = 13;
					quesExplanation.explanationText = _currQues.explanation;
				}
				
				//populate statement
				quesStatement.text = _currQues.quesStatement;
				currQuesMark = _currQues.quesMark.toString();
				
				if(_currQues._imagePath.length == 0)
				{
					diagram.visible = false;
				}
				else
				{
					diagram.visible = true;
					diagram.setImage(_currQues._imagePath);
				}
				
				//populate choice box
				choiceBox.populateChoices(_currQues);
			}
			
			protected function reviewCheckBoxClickHandler(event:MouseEvent):void
			{
				if(quesReviewCheckBox.selected == true)
				{
					currQues.isQuesMarkedForReview = true;
				}
				
				else
				{
					currQues.isQuesMarkedForReview = false;
				}
			}
			
			protected function testQuitButtonClicked(event:Event):void
			{
				var newEvent:Event = new Event(MCQConstants.testQuitEventName);
				dispatchEvent(newEvent);
			}
			
			protected function expandExplanation(event:Event):void
			{
				if(isExplanationExpanded)
				{
					quesExplanation.percentHeight = 13;
					isExplanationExpanded = false;
				}
					
				else
				{
					quesExplanation.percentHeight = 60;
					isExplanationExpanded = true;
				}

			}
			
			
		]]>
	</fx:Script>
	<s:states>
		<s:State name="TestMode"/>
		<s:State name="ReviewMode"/>
	</s:states>
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<s:layout>
		<s:BasicLayout>
		</s:BasicLayout>
	</s:layout>
	<s:BorderContainer left="10" top="10" bottom="10" width="78%">
		<components:choicesBox id="choiceBox" left="20" width="70%" height="50%"
							   top="120">
		</components:choicesBox>
		<s:RichText id="quesStatement" left="20" top="40" width="90%" height="15%"
					chromeColor="#FCFBFB" color="#678C60" fontFamily="Verdana"
					 paddingBottom="10" paddingTop="10" text="Sample statement"
					textAlign="left" verticalAlign="top"
					fontSize="18" fontWeight="normal"/>
		<GeneralComponents:DiagramDisplayer id="diagram" right="10" top="120" width="25%" height="40%"
									 />
		<components:ExplanationBar id="quesExplanation" includeIn="ReviewMode" bottom="20"
								   width="70%" height="13%" horizontalCenter="0"
								   click="expandExplanation(event)">
		</components:ExplanationBar>
		
		<s:Button id="nextButton" right="10" bottom="20" width="7%" height="7%" label="Next"
				  click="quesChangedEventHandler(event)"
				  chromeColor.TestMode="#DD9C9C"/>
		
		<s:Button id="prevButton" width="7%" height="7%" label="Previous"
				  click="quesChangedEventHandler(event)"
				  left="10" bottom="20"/>
		<s:CheckBox id="quesReviewCheckBox" includeIn="TestMode" bottom="20" height="5%"
					label="Mark For Review Later" click="reviewCheckBoxClickHandler(event)"
					fontStyle="italic" horizontalCenter="0" textDecoration="underline"/>
		<s:Button includeIn="TestMode" right="0" top="0" width="10%" height="4%" label="Quit"
				  click="testQuitButtonClicked(event)"
				  />
		
		<!--s:Button click="currentState = 'ReviewMode'" x="300" y="200"/-->
	</s:BorderContainer>
	<s:Panel right="6" top="10" bottom="10" width="20%">
		<s:Button bottom="20" width="50%" height="5%" label="Done" click="FinishHandler(event)"
				  horizontalCenter="0"
				  bottom.TestMode="20" horizontalCenter.TestMode="0"/>
		
		<s:Button top="20" width="50%" height="5%" label="Help"
				  horizontalCenter="0"
				  click="HelpClickHandler(event)"/>
		<components:questionsButtBox id="quesBox" width="95%" height="20%"
									 top="75" horizontalCenter="0">
		</components:questionsButtBox>
		<s:BorderContainer includeIn="TestMode" bottom="80" width="80%" height="80" borderWeight="3"
						   cornerRadius="8" horizontalCenter="0">
			<s:RichText id="timer" color="#54AD69" fontSize="19" fontWeight="bold" horizontalCenter="0"
						text="{timeLeft}" textAlign="center" verticalAlign="middle" verticalCenter="0"/>
		</s:BorderContainer>
		<mx:ProgressBar id="quesProgress" includeIn="TestMode" width="80%" height="36"
						horizontalCenter="0" verticalCenter="90" minimum="0" mode="manual"/>
		<s:Label height="7%" color="#419194"
				 fontStyle="italic" text="Marks : {currQuesMark}"
				 width="80%" fontFamily="Verdana" fontSize="23"
				 fontWeight="normal" horizontalCenter="0" textAlign="left"
				 verticalAlign="justify" verticalCenter="-20"/>
	</s:Panel>
</s:Group>
